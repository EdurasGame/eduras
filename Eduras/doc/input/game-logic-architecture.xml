<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
	<articleinfo>
		<title>Architecture of game logic</title>
		<author>
			<firstname>Florian</firstname>
			<surname>Mai</surname>
		</author>
	</articleinfo>

	<section>

		<title>What's this?</title>

		<para>
			<emphasis role="strike">This chapter concerns the composition of the game logic. We try
			to document
			any part of that in here as long as it is not self
			explanatory or easily understood reading
			the javadoc documentation of
			the corresponding classes.</emphasis> This chapter shows and explains some of the architectural
			aspects of the game logic. It rather addresses the abstract concepts than detailed information
			on classes.
		</para>

	</section>
	
	<section>
	    <title>Client and server logics</title>
	    <section>
	        <title>The story of the two logics</title>
	    <para>
	        When the project once started we were sure that we don't need a distinction between
	        the logic on the client and the logic on the server, since both would actually do the same
	        but with the client's logic being updated by the server's state frequently. That turned out
	        to be non-sense. Starting with asynchronous object ids on client and server, more and more
	        problems, mostly concerns of synchrony, arose. We added several interfaces that were called
	        in different situations in the logic to work around the problems but preserve the architecture
	        with the same logic on client and server. Some day we came to a point where we realized that
	        our first approach was <empahsis>shit</empahsis>. That's why there are two different logics
	        that mostly serve very different purposes.
	    </para>
	    </section>
	    <section>
	        <title>Client logic</title>
	        <para>
	            The client logic's main purpose is to store the state of the game and to calculate/predict the future's
	            game state in advance in order to offer a more fluent game experience to the user. <emphasis>We
	            need to verify that the user experience is actually improved by precalculating the future
	            gamestate!</emphasis> The client's game state is then overwritten by the more accurate (and synchronous) game
	            state that is calculated on the server. For now, the only thing that is precalculated is the object's
	            new positions. Typical events that are processed by the client's logic are SET events (SET_POS,
	            SET_HEALTH...). Look at the 'Events' document for a list of all events. You can add a GameEventListener
	            to the client logic that serves as a callback called when certain events appear. For example the
	            GUI implements such a Listener to react on game events, but you can think of other kinds of listeners
	            as well (for example a listener that records statistics).
	        </para>
	        
	    </section>
	    
	    <section>
	        <title>Server logic</title>
	        <para>
	            The server logic is responsible for keeping the clients synchronous. Thus it creates objects (and
	            sets their ids), recalculates health and other critical values and informs the clients about those.
	            The ServerEventTriggerer is a class that provides several methods that not only change the state of
	            the game but also inform the clients at the same time. 
	            <emphasis>Whenever you want to change the state of the game, use one of the methods provided
	            by the ServerEventListener or implement a new method in it so others can use those methods
	            too!</emphasis> The server mostly processes input from the user. For example, if the user presses
	            a key to use an item on the client, the client will send an event USE_ITEM to the server which then
	            verifies whether the client is actually allowed to use it. <emphasis>We should consider to
	            move this process partially or completely to the client or check whether that is possible at all.
	            </emphasis>
	        </para>
	    </section>
	</section>

	<section>
		<title>The architecture</title>
		
		<para>
			<emphasis role='strike'>The following figure shows most of the classes you will find in the
			game logic. Note that some operations
			or attributes might be left out
			in the figure since they are not that important or unnecessary to
			mention,
			e.g. getter and setter methods.</emphasis>Note that the following figure is out-of-date.
			<informalfigure>
				<graphic fileref="images/gamelogicclasses.jpg"></graphic>
			</informalfigure>
		</para>

		<para>
			As main entry point to the game logic there is a class that
			implements 'GameLogicInterface'.
			The interface shall provide any
			services the IEP (see high-level-architecture) needs.
			Especially it
			shall give access to a so called 'GameInfo' class, which provides
			information about
			the currently ongoing match. For a first increment,
			GameInfo cointains a list of all the objects in the
			game and about the
			map.
		</para>
		<para>
			<emphasis role="strike">A map itself contains of a number of fields
				(as a
				two-dimensional array, indicating
				x- and y-positions).
			</emphasis>
		</para>
		<para>
			A map itself has a width and height representing the bounds of
			the map.
		</para>

		<section>
			<title>GameObjects</title>
			<para>
				A GameObject represents an object that is physically on the map.
				So it's characterized by a current x- and y-position
				on the map. As
				the map bounds are positive, the x and y positions are typically
				positive.
			</para>
			<para>
				The following figure shows in detail what characterizes a GameObject.
				<informalfigure>
					<graphic fileref="images/gameobjecthierachry.jpg"></graphic>
				</informalfigure>
			</para>
			<para>
				A gameobject is identified by its identifier. Also, a gameObject
				always belongs to some owner (let it be CPU if it does not belong to
				any player). Every object has a specific behaviour when it collides
				with another object. Thus subclasses must override 'onCollision'.
			</para>
			<para>Collision is checked when a MovableObject moves (see chapter 'Collision'). A
				MovableObject
				moves with a speed and into a direction given by the
				speedVector.
				With every call of 'onMove' the passed time from the last
				move is
				needed to calculate the absolute movement out of the speed and
				speedVector.
			</para>
			
			<para>
				Furthermore each GameObject consists of an ObjectShape
				indicating how a GameObject looks like. A big group of shapes are polygons. Polygons have much in common so there is a superclass for all of these. A polygon consists of a number
				of relative points in the two-dimensional space and the lines between two points i and i + 1 are assumed to be a border of the polygon. Out of these
				relative points you can get the shape of a specific gameObject by
				combining the gameobjects position with the shapepoints (call
				getAbsoluteVertices() for this purpose). Of course, checking a
				collision is
				always dependent on how the shape of the gameobject looks  
				like. <emphasis role='strike'> Since there might be different best-practices for calculating a
				collsion for different shapes, every shape has to implement
				checkCollision(). </emphasis> Every shape has to implement 'getBorderPoints' and 'isIntersected' to be able to check for a collision.
			</para>
		
			<section>
				<title>Player</title>
				
				<para>A player is a special movable object, which represents the character a user controls. Therefore it's got a name and an inventory of items.</para>
			</section>
			<section>
				<title>Item</title>
				
				<para>
					The following figure shows what items look like:
					<informalfigure>
						<graphic fileref="images/items.jpg"></graphic>
					</informalfigure>
				
				</para>
				
				<para>
					As you can see, an inventory can keep a number of items. Special items can implement the 'Usable' interface,
					 telling that the user shall be able to trigger the item by choosing 
					it in the inventory and eventually clicking somewhere. Weapons are special items which
					 have a bullet prototype and a cooldown. Weapons implement the use() function in
					 which new bullets or missiles shall be created.
				</para>
			</section>

		</section>
	</section>

</article>