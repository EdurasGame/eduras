<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
	<articleinfo>
		<title>Architecture of game logic</title>
		<author>
			<firstname>Florian</firstname>
			<surname>Mai</surname>
		</author>
	</articleinfo>

	<section>

		<title>What's this?</title>

		<para>
			This chapter concerns the composition of the game logic. We try
			to document
			any part of that in here as long as it is not self
			explanatory or easily understood reading
			the javadoc documentation of
			the corresponding classes.
		</para>

	</section>

	<section>
		<title>The architecture</title>

		<para>
			The following figure shows most of the classes you will find in the
			game logic. Note that some operations
			or attributes might be left out
			in the figure since they are not that important or unnecessary to
			mention,
			e.g. getter and setter methods.
			<informalfigure>
				<graphic fileref="images/gamelogicclasses.jpg"></graphic>
			</informalfigure>
		</para>

		<para>
			As main entry point to the game logic there is a class that
			implements 'GameLogicInterface'.
			The interface shall provide any
			services the IEP (see high-level-architecture) needs.
			Especially it
			shall give access to a so called 'GameInfo' class, which provides
			information about
			the currently ongoing match. For a first increment,
			GameInfo cointains a list of all the objects in the
			game and about the
			map.
		</para>
		<para>
			<emphasis role="strike">A map itself contains of a number of fields
				(as a
				two-dimensional array, indicating
				x- and y-positions).
			</emphasis>
		</para>
		<para>
			A map itself has a width and height representing the bounds of
			the map.
		</para>

		<section>
			<title>GameObjects</title>
			<para>
				A GameObject represents an object that is physically on the map.
				So it's characterized by a current x- and y-position
				on the map. As
				the map bounds are positive, the x and y positions are typically
				positive.
			</para>
			<para>
				The following figure shows in detail what characterizes a GameObject.
				<informalfigure>
					<graphic fileref="images/gameobjecthierachry.jpg"></graphic>
				</informalfigure>
			</para>
			<para>
				A gameobject is identified by its identifier. Also, a gameObject
				always belongs to some owner (let it be CPU if it does not belong to
				any player). Every object has a specific behaviour when it collides
				with another object. Thus subclasses must override 'onCollision'.
			</para>
			<para>Collision is checked when a MovableObject moves (see chapter 'Collision'). A
				MovableObject
				moves with a speed and into a direction given by the
				speedVector.
				With every call of 'onMove' the passed time from the last
				move is
				needed to calculate the absolute movement out of the speed and
				speedVector.
			</para>
			
			<para>
				Furthermore each GameObject consists of an ObjectShape
				indicating how a GameObject looks like. A big group of shapes are polygons. Polygons have much in common so there is a superclass for all of these. A polygon consists of a number
				of relative points in the two-dimensional space and the lines between two points i and i + 1 are assumed to be a border of the polygon. Out of these
				relative points you can get the shape of a specific gameObject by
				combining the gameobjects position with the shapepoints (call
				getAbsoluteVertices() for this purpose). Of course, checking a
				collision is
				always dependent on how the shape of the gameobject looks  
				like. <emphasis role='strike'> Since there might be different best-practices for calculating a
				collsion for different shapes, every shape has to implement
				checkCollision(). </emphasis> Every shape has to implement 'getBorderPoints' and 'isIntersected' to be able to check for a collision.
			</para>
		
			<section>
				<title>Player</title>
				
				<para>A player is a special movable object, which represents the character a user controls. Therefore it's got a name and an inventory of items.</para>
			</section>
			<section>
				<title>Item</title>
				
				<para>
					The following figure shows what items look like:
					<informalfigure>
						<graphic fileref="images/items.jpg"></graphic>
					</informalfigure>
				
				</para>
				
				<para>
					As you can see, an inventory can keep a number of items. Special items can implement the 'Usable' interface,
					 telling that the user shall be able to trigger the item by choosing 
					it in the inventory and eventually clicking somewhere. Weapons are special items which
					 have a bullet prototype and a cooldown. Weapons implement the use() function in
					 which new bullets or missiles shall be created.
				</para>
			</section>

		</section>
	</section>

</article>