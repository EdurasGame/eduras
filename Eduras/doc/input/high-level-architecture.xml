<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
	<articleinfo>
		<title>High level architecture</title>
	</articleinfo>

	<section>

		<title>(fma) What's this about?</title>

		<para>In this chapter we want to explain how the project's
			architecture is going to look like, not in detail, but from an
			abstract point of view. The components you may encounter in this
			chapter might not have been implemented yet, might be named elsewise
			or split up into several smaller components.
		</para>

	</section>

	<section>

		<title>(fma) The architecture</title>

		<para>
			The architecture will look as follows:
			<informalfigure>
				<graphic fileref="images/architecturedataflow.jpg"></graphic>
			</informalfigure>
		</para>
		<para>
			The game logic is completely encapsulated from the GUI. The GUI
			can only gain information via the so called 'Information- and event
			provider' (IEP), which serves as a special API to the game logic,
			providing only the information the GUI needs. This has a few advantages:
		</para>
		
		
		<itemizedlist>
			
			<listitem>
				<para>
					The GUI can be exchanged easily, since it is not directly connected to parts of
					the program. A new GUI 'simply' has to implement the API provided by the IEP.
				</para>
				
				<para>
					By reducing or enlarging the IEP-API, we have better control on what information the user is
					allowed to be told.
				</para>
				
			</listitem>
			
		</itemizedlist>
		
		
		<para>
			The IEP serves a second purpose: The GUI can use it to trigger
			events on the game logic. A triggered event is then passed to the game
			logic of the client and to the network, which passes it to the game
			logic of the server. Having received the events, client game logic or
			server game logic respectivly calculate some new game data.
			The	server's new game data are then passed to the client and overwrite
			existing game data on the client's game logic.
		</para>
		
		<para>
			You might wonder why it's needed to calculate new game data twice,
			once on the client's game logic and once on the server's game logic.
			This is because we must ensure that the user experiences a fluent
			game, thus we cannot wait for information to be passed via network
			twice. This takes too much time.
		</para>

	</section>
	
	<section>
		
		<title>(fma) An example</title>
		
		<para>
			We want to give an example that hopefully clarifies how data is processed
			in our program.
		</para>
		
		<para>
			Think of a GUI where a player can move its character by pressing the Right-Arrow-Button on
			his keyboard. The following diagram shows what steps are to be taken when the Right-Arrow-Button
			is pressed.
		</para>
		
		<para>
			<informalfigure>
				<graphic fileref="images/MOVE_RIGHT_event.jpg"></graphic>
			</informalfigure>
		</para>
	
	</section>

</article>