<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
	<articleinfo>
		<title>Interaction modes</title>
		<author>
			<firstname>Jannis</firstname>
			<surname>Mell</surname>
		</author>
	</articleinfo>
	<section>
		<title>What's this about?</title>
		<para>
			In this chapter, we try to discuss and elaborate the new so-called
			"build mode" that should be introduced in alpha2. This mode is somehow
			designed to expand during development and thus this document may not
			cover all design aspects yet.
		</para>
	</section>
	<section>
		<title>Nomenclature</title>
		<itemizedlist>
			<listitem>
				<para><emphasis>player</emphasis> - describes the (human) enduser
				as a person.
				</para>
			</listitem>
			<listitem>
				<para><emphasis>mainfigure</emphasis> - descibes the unit that
				each player controls primarily.
				</para>
			</listitem>
		</itemizedlist>
	</section>
	<section>
		<title>What is the build mode?</title>
		<para>
			The build mode should provide a brand new stunning feature for Eduras?
			To compensate the ego-mode, this mode brings a strategy element into
			the game: It allows the player to control units of his team and
			command them to move to a specific location or perform a specific
			action.
		</para>
		<section>
			<title>Distinction from ego-mode</title>
			<para>
				In contrary to the ego-mode, the build mode does not allow the
				player to control his mainfigure. Instead, it allows the player
				to freely scroll the map and to command units of his team
				that are not under control of any other player. Additionaly, he
				may be able to create buildings or other small tools like traps.
			</para>
			<para>
				The following table tries to describe all differences from ego
				mode in detail.
			</para>
			<table frame="all">
				<title>Differences between ego-mode and build mode.</title>
				<tgroup cols="2">
					<thead>
						<row>
							<entry>ego-mode</entry>
							<entry>build mode</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>player-centered scrolling</entry>
							<entry>free scrolling</entry>
						</row>
						<row>
							<entry>control only mainfigure</entry>
							<entry>control AI units in same team</entry>
						</row>
						<row>
							<entry>items and inventory</entry>
							<entry>skillbar and team resources</entry>
						</row> 
						<row>
							<entry>user uses mouse to shoot</entry>
							<entry>user uses mouse to select units and command them</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</section>
		<section>
			<title>Design aspects</title>
			<para>
				To make the mode decision more important to the player, (fma) in some
				game modes or depending on the settings (/fma)
				the mode cannot be changed immediately (fma) nor at any place (/fma). 
				There is a cooldown
				after changing mode that prevents the player from switching back
				instantly.
				In addition to that, each mode can have an individual minimum time.
			</para>
			<figure>
	            <title>An example mode switch flow</title>
	            <mediaobject>
	                <imageobject>
	                    <imagedata fileref="images/modes_modeswitch.png" format="PNG" />
	                </imageobject>
	            </mediaobject>
	        </figure>
			<para>
				(fma) Depending on game settings (/fma) the mainfigures of players that 
				switched to build mode
				(fma) might (/fma) stay at its position and thus is still vulnerable.
				The player should care for his mainfigure himself (fma)(or good communication
				between teammembers is necessary :)) (/fma).
				Due to the switching cooldown, this may be a tricky task that
				leads players to switch to this mode only if they are in a safe
				position.
			</para>
		</section>
		<section>
			<title>Artificial intelligence</title>
			
			<section>
			    <title>Option 1</title>
			
			<para>
				Units need to have to think for themselves in some way, therefore they
				need some kind of AI.
				The AI should be capable of some essential actions like moving, shooting
				and so on.
				
			</para>
			<para>
				The following scheme shows the general structure of artificial intelligence.
				Individual parts are described below.
			</para>
			<figure>
	            <title>structure of artificial intelligence</title>
	            <mediaobject>
	                <imageobject>
	                    <imagedata fileref="images/ai.png" format="PNG" />
	                </imageobject>
	            </mediaobject>
	        </figure>
	        <para>
	        	The key part is represented by the <emphasis>UnitAI</emphasis>.
	        	It provides general asynchronous methods that command the associated
	        	unit. The AI is able to react on unit's death, too. 
	        </para>
	        <para>
	        	The final <emphasis>UnitMover</emphasis> class is responsible for handling
	        	asynchronous unit actions.
	        	It holds a Runnable object that repeatedly updates unit's moving direction. It handles
	        	the creation of new runnable instances and cares for thread concurrency.
	        	To receive the path information it uses a <emphasis>PathFinder</emphasis>.
	        </para>
	        <para>
	        	The <emphasis>PathFinder</emphasis> interface provides automatic pathfinding.
	        	The PathFinder interface is described detailled further below.
	        </para>
	        </section>
	        <section>
	            <title>(fma)Option 2</title>
	            <para>
	                Another option is to omit AI completely. That definitively sounds weird, but
	                is also a new game experience as well. Omitting AI means, there is no process in
	                the background that autonomously triggers units to move, shoot, use items or do
	                anything else. Every action has to be triggered by the user explicitly. That would
	                have the following consequences:
	            </para>
	            <itemizedlist>
	                <listitem>
	                    <para>
	                		Less work: Since the required code of option 2 is a subset of the required code
	                		of option 1, there is less to worry about. All we need then are the events
	                		described later.
	            		</para>
	                </listitem>
	                <listitem>
	                    <para>
	                        Less non-determinism: If we realized option 1, we would have to integrate some
	                        kind of chance because units that always hit when they shoot are not very
	                        much fun (in a shooter). By omitting that success would be caused by the players' skills rather
	                        than fortune.
	                    </para>
	                </listitem>
	                <listitem>
	                    <para>
	                        More challenging gameplay: The gameplay would be more challenging for players using
	                        interactive mode. That can be used as one factor for balancing between interactive
	                        and ego mode.
	                    </para>
	                </listitem>
	            
	            </itemizedlist>
	        </section>
	        
	        <section>
	            <title>
	                (fma)Summary
	            </title>
	            <para>
	                As the AI can be seen as an additional feature set on top of option 2, we should implement
	                both options and make available to the user via different gamemodes/settings. What ever turns
	                out to be more satisfactory to the user can be focused on later.
	            </para>
	        </section>
	    </section>
	</section>
	<section>
		<title>Implementation: ideas and problems</title>
		<para>
			This chapter provides a more detailed look on design ideas and implementation
			of some aspects regarding mode changes and build mode.
		</para>
		<para>
			Let's take another look at table one and think about what these points mean
			for implementation steps:
		</para>
		<table frame="all">
		<title>Differences between ego-mode and build mode regarding implementation</title>
			<tgroup cols="2">
				<thead>
					<row>
						<entry>ego-mode</entry>
						<entry>build mode</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>camera is updated regularily to keep it centered</entry>
						<entry>the mouse listener has to react when user moves mouse near frame borders</entry>
					</row>
					<row>
						<entry>GUI clicks result in item use triggers</entry>
						<entry>GUI clicks triggers logic to find units at these points. Right clicks trigger sent_units events.</entry>
					</row>
					<row>
						<entry>Display for player stats and inventory</entry>
						<entry>Display for stats of selected units and team resources</entry>
					</row>
				</tbody>
			</tgroup>
		
		</table>
		<section>
			<title>Pathfinding</title>
			<para>
				To fulfill the requirements of the AI, we need to implement a general
				pathfinding API.
			</para>
			<figure>
	            <title>The PathFinder interface</title>
	            <mediaobject>
	                <imageobject>
	                    <imagedata fileref="images/modes_pathfinder.png" format="PNG" />
	                </imageobject>
	            </mediaobject>
	        </figure>
	        <para>
		        The method <computeroutput>setTarget</computeroutput> should throw an
		        exception if the target point is not reachable (because it's in a block
		        or there is no way to reach the point). (fma) In non-AI interactive mode
		        the unit could simply stop whenever it collides with something. (/fma)
		    </para>
		    <para>
		    	A very important aspect of pathfinding is that the generated path must
		    	keep distance to other objects. Otherwise, the moving object might
		    	stuck.
		    </para>
		    <para>
		    	However, every implementation must calculate the complete path first
		    	before it can provide sufficient waypoints. As an example, take a
		    	look at the
		    	<ulink url="http://en.wikipedia.org/wiki/A*_search_algorithm">A* algorithm</ulink>.
		    </para>
			<figure>
	            <title>Distance problem when calculating paths</title>
	            <mediaobject>
	                <imageobject>
	                    <imagedata fileref="images/modes_pathfinding_distance.png" format="PNG" />
	                </imageobject>
	            </mediaobject>
	        </figure>
	        <para>
		    	The plan is to provide several simple pathfinding implementations that
		    	cover different kinds of moving (flying, walking, hovering, crawling etc).
		    </para>
		    <figure>
	            <title>A basic pathfinder mechanism</title>
	            <mediaobject>
	                <imageobject>
	                    <imagedata fileref="images/modes_pathfinding_illustration.png" format="PNG" />
	                </imageobject>
	            </mediaobject>
	        </figure>
	        <para>
	        	The implementation of the run method in UnitMover could look like the following (pseudocode):
	        </para>
	        <programlisting>active = true;
while(!pathFinder.hasReachedTarget()) {
	unit.setSpeedVector(pathFinder.getMovingDirection());
	pathFinder.setLocation(unit.currentLoc);
	Thread.sleep(200);
}
active = false;
</programlisting>
		</section>
		<section>
			<title>Unit selection and commanding</title>
			<para>
				To reduce server load, the client should keep track of selected units.
				The server will check whether a player is allowed to control that
				units or not anyway.
			</para>
			<figure>
	            <title>Overview on the flow of selection and commanding units</title>
	            <mediaobject>
	                <imageobject>
	                    <imagedata fileref="images/modes_selectcommandflow.png" format="PNG" />
	                </imageobject>
	            </mediaobject>
	        </figure>
	        <para>
	            (fma) Well done! (/fma)
	        </para>
		</section>
	</section>
	<section>
		<title>Programming requirements</title>
		<para>
			This is a very concise list of all things required to do. The list
			is not sorted by a special order and there might be some things missing.
		</para>
		<para>
			Though some tasks may be simple (e.g. creating an event), keep an eye on
			the implementation section to get more details on how to
			implement special things.
		</para>
		<section>
			<title>Small/simple tasks</title>
			<orderedlist>
				<listitem>
					<para>
						<computeroutput>enum InteractMode { MODE_EGO, MODE_STRATEGY }</computeroutput>
						in playermainfigure
					</para>
				</listitem>
				<listitem>
					<para>
						The logic needs to track each players mode, so a new attribute
						<computeroutput>interactMode</computeroutput> is required. It
						contains the respective enum value of players current mode.
					</para>
					<para>
						In addition, the time of the most recent mode switch of each
						player is required: <computeroutput>long lastModeSwitch</computeroutput>
					</para>
				</listitem>
				<listitem>
					<para>
						New client event: SWITCH_INTERACTMODE
					</para>
					<table>
						<title>Event arguments for SWITCH_INTERACTMODE</title>
						<tgroup cols="5">
							<thead>
								<row>
									<entry>Event</entry>
									<entry>Id=arg0</entry>
									<entry>Description</entry>
									<entry>arg1</entry>
									<entry>arg2</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>SWITCH_INTERACTMODE</entry>
									<entry>40</entry>
									<entry>Indicates that player wants to change interaction mode.</entry>
									<entry>ownerId</entry>
									<entry>newMode</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</listitem>
				<listitem>
					<para>
						New server event: SET_INTERACTMODE
					</para>
					<table>
						<title>Event arguments for SET_INTERACTMODE</title>
						<tgroup cols="5">
							<thead>
								<row>
									<entry>Event</entry>
									<entry>Id=arg0</entry>
									<entry>Description</entry>
									<entry>arg1</entry>
									<entry>arg2</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>SET_INTERACTMODE</entry>
									<entry>141</entry>
									<entry>Sets interact mode of a player.</entry>
									<entry>ownerId</entry>
									<entry>newMode</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</listitem>
				<listitem>
					<para>
						Add a gui button and/or shortcut for switching modes
						and display the current mode and cooldown
					</para>
				</listitem>
				<listitem>
					<para>
						New client event: SEND_UNITS
					</para>
					<table>
						<title>Event arguments for SEND_UNITS</title>
						<tgroup cols="8">
							<thead>
								<row>
									<entry>Event</entry>
									<entry>Id=arg0</entry>
									<entry>Description</entry>
									<entry>arg1</entry>
									<entry>arg2</entry>
									<entry>arg3</entry>
									<entry>arg4</entry>
									<entry>arg5, arg6...</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>SEND_UNITS</entry>
									<entry>41</entry>
									<entry>Sends one or multiple units to a given location</entry>
									<entry>ownerId (commander)</entry>
									<entry>targetX</entry>
									<entry>targetY</entry>
									<entry>unitId</entry>
									<entry>(more unit ids...)</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</listitem>
				<listitem>
					<para>
						Implementation of <emphasis>UnitMover</emphasis> class.
					</para>
				</listitem>
			</orderedlist>		
		</section>
		<section>
			<title>Bigger tasks</title>
			<para>
				Some of these tasks may have to be splitted into multiple subtasks.
			</para>
			<orderedlist>
				<listitem>
					<para>
						Allow selection of units on clientside (in build mode only).
						The player selects units by clicking them directly (single 
						selection) or drags a rectangle around them (group selection).
					</para>
				</listitem>
				<listitem>
					<para>
						Create a gui that shows selected units and action buttons
					</para>
				</listitem>
			
			
			</orderedlist>
		</section>
	</section>
</article>