<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
	<articleinfo>
	    <title>Getting started</title>
		<author>
			<firstname>Florian</firstname>
			<surname>Mai</surname>
		</author>
		<author>
			<firstname id="jannis">Jannis</firstname>
			<surname>Mell</surname>
		</author>
	</articleinfo>
	
	<section>
	
		<title>Intended audience</title>
		
		<para>
			This getting-started guide should be read by any developer, project-
			manager or any other person who is connected to this project. It
			will contain information that is needed to get started working on this
			project or with the outcomes of this project.
		</para>
	</section>
	
	<section>
		<title>Programming language</title>
		
		<para>
			As it is very natural for games, we were sure about using an
			object-orientated programming language very early and so it was about
			to decide between the big ones, Java and C++, each of them having
			significant advantages and disadvantages. C++ of course is more difficult
			to work with since there is no automated memory management and not such a
			huge amount of free libraries as it's known from Java. Actually C++ is more
			often the programming language of choice in a gaming context since most
			(professional) games come along with big calculations and therefore Java
			with its virtual machine delay may not be fast enough. Especially for an
			eSports game played via network speed is a critical factor. But nevertheless
			we are confident that our game - having in mind to keep things simple in it -
			will not include such big calculations, so Java will work. Java also provides
			the simplest way of being platform independent. Not at last, we are
			much more familiar with Java than we are with C++. Due to these reasons we
			prefer Java to C++.
		</para>
	</section>
	
	<section>
	
		<title>Version Control Management System</title>
		
		<para>
			For this project we will use GIT for version control. GIT is a very
			popular distributed version control tool, that has already got well working
			plugins for common IDEs and so will be easy to work with.
		</para>
		
		<section>
			<title>Commits</title>
			<para>
				Every commit you make should have a tag as prefix to mark what your commit
				will be about. If your tag touches a very wide field, you should think about
				a subtag to bring into more detail. So people who view new changes can easily
				detect whether a specific commit is of interest for the person or not.
			</para>
			
			<para>
				Your commits should be short and meaningful. You shall not detailedly describe
				what you did but at some meta-level. Of course, this lies in some way much in
				the estimation of the commiter, so you can't really tell what a good commit is
				and what is not. To give a hint, think of a bugfix in some calculation where
				there was an accidentally inserted '<=' replaced by a '<'. In the commit it would
				be far enough to only tell that you fixed a minor bug and you don't need to tell
				why, where, what or when. On the other hand, think of a function, where you do some
				calculation on a list. You find out that the number of elements in the list is a
				disctinct value and you want to replace the list by an array due to performance
				reasons. Then your commit message should contain information about why it's possible
				and useful to replace the list by an array. A third example: You created a new class
				that sets up a network connection. Simply tell this in your commit message. All
				additional information a reader might want to get should be found in the source code
				documentation.
			</para>
			
			<para>For example, the commit for adding the description of how to make a commit
			may look like this: [DOCUMENTATION][COMMITS] Added a description of how commits should look
			like.
			</para>
			
		</section>
	
	</section>
	
	
	<section>
	
		<title>Continuous Integration</title>
		
		<para>
			We should really think about introducing a continuous integration platform such
			as <ulink url="http://jenkins-ci.org/">Jenkins</ulink>. These tools offer a lot
			of automating-mechanisms which we can use to automate various jobs such as building
			the project or documentation, running unit tests and so on. It also is able to
			provide an overview of TODOs in	the source code and much more. We could also integrate
			these features into our own web-platform being developed by Jannis. (TODO: Reference to
			Jannis). But I think that would be much too costly. Using Jenkins (or another CI tool)
			as an extension to our platform should work well.
		</para>
	</section>
</article>