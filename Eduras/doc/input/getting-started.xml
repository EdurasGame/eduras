<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
	<articleinfo>
	    <title>Getting started</title>
	</articleinfo>
	
	<section>
	
		<title>(fma) Intended audience</title>
		
		<para>
			This getting-started guide should be read by any developer, project-
			manager or any other person who is connected to this project. It
			will contain information that is needed to get started working on this
			project or with the outcomes of this project.
		</para>
	</section>
	
	<section>
		<title>(fma) Programming language</title>
		
		<para>
			As it is very natural for games, we were sure about using an
			object-orientated programming language very early and so it was about
			to decide between the big ones, Java and C++, each of them having
			significant advantages and disadvantages. C++ of course is more difficult
			to work with since there is no automated memory management and not such a
			huge amount of free libraries as it's known from Java. Actually C++ is more
			often the programming language of choice in a gaming context since most
			(professional) games come along with big calculations and therefore Java
			with its virtual machine delay may not be fast enough. Especially for an
			eSports game played via network speed is a critical factor. But nevertheless
			we are confident that our game - having in mind to keep things simple in it -
			will not include such big calculations, so Java will work. Java also provides
			the simplest way of being platform independent. Not at last, we are
			much more familiar with Java than we are with C++. Due to these reasons we
			prefer Java to C++.
		</para>
	</section>
	<section>
		<title>(jme) Development tools (Java)</title>
		<para>
			We use <ulink url="http://www.eclipse.org">Eclipse</ulink> ("Eclipse IDE for Java Developers") to edit and work on our Java-source.
			You may use other development tools like NetBeans but we really encourage you to use eclipse as
			it makes a lot of things easier using the same tool: There will be less line-break changes or indention
			changes on each commit. This will result in easier merge processes.
			<emphasis>Note:</emphasis> we are not working with Java Enterprise (Java EE).
		</para>
	</section>
	<section>
		<title>(jme) Coding guidelines</title>
		<para>
			Currently, we use default formatter of Eclipse that includes a maximum line width of 80.
			We plan to provide a custom profile with our customized settings.
			Using output or gui display, you have to localize your strings.
		</para>
	</section>
	<section>
		<title>(fma) Build tool</title>
		
		<para>
			We will use <ulink url="http://ant.apache.org/">Ant</ulink> to automated our
			builds. Ant is very popular in a Java context and thus has good support for
			plugins in your favorite IDE.
		</para>
	</section>
	
	<section>
	
		<title>(fma) Version Control Management System</title>
		
		<para>
			For this project we will use <ulink url="http://git-scm.com/">Git</ulink> for version control. Git is a very
			popular distributed version control tool, that has already got well working
			plugins for common IDEs and so will be easy to work with.
		</para>
		
		<section>
			<title>Commits</title>
			<para>
				Every commit you make should have a tag as prefix to mark what your commit
				will be about. If your tag touches a very wide field, you should think about
				a subtag to bring into more detail. So people who view new changes can easily
				detect whether a specific commit is of interest for the person or not.
			</para>
			
			<para>
				Your commits should be short and meaningful. You shall not detailedly describe
				what you did but at some meta-level. Of course, this lies in some way much in
				the estimation of the commiter, so you can't really tell what a good commit is
				and what is not. To give a hint, think of a bugfix in some calculation where
				there was an accidentally inserted '&lt;=' replaced by a '&lt;'. In the commit it would
				be far enough to only tell that you fixed a minor bug and you don't need to tell
				why, where, what or when. On the other hand, think of a function, where you do some
				calculation on a list. You find out that the number of elements in the list is a
				disctinct value and you want to replace the list by an array due to performance
				reasons. Then your commit message should contain information about why it's possible
				and useful to replace the list by an array. A third example: You created a new class
				that sets up a network connection. Simply tell this in your commit message. All
				additional information a reader might want to get should be found in the source code
				documentation.
			</para>
			<para>
				For example, the commit for adding the description of how to make a commit
				may look like this: <code>[DOCUMENTATION][COMMITS] Added a description of how commits should look
				like.</code>
			</para>
			<para>
				(jme) In general, using more commits is better than using less. Feel free to commit every time you
				worked on a specific topic or made a big change. Sometimes it is not easy to stop workflow to
				make a commit, but keeping overview is an important thing. Take a look at two examples below to get
				a better feeling about when to commit. (/jme)
			</para>
			<para>
				(jme) <emphasis>Example 1:</emphasis> Say, you made the following two changes: Firstly you added
				a section about disconnect handling in documentation. After that you implemented described
				behaviour in source code. At this point you should have made two commits. Both your changes
				handled same topic but there is a big difference between documentating and implentating a feature.
				So, please commit your doc-changes first and start developing on code, then. Your commits could
				look like following:
			</para>
			<itemizedlist>
				<listitem>
					<para>
						<code>[DOCUMENTATION][ERRORHANDLING] Described behaviour on network-disconnects.</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<code>[NETWORKING][ERRORS] Implemented handling of disconnects.</code>
					</para>
				</listitem>
				<listitem>
					<para>
						<emphasis>Wrong:</emphasis> <code>[ERRORHANDLING] Implemented and documentated handling of disconnects.</code>
					</para>
				</listitem>
			</itemizedlist>
			<para>
				<emphasis>Example 2:</emphasis> You elaborate your thoughts and add two big sections to documentation:
				A big section on teamplay and a list of different game weapons. Both additions belong to documentation,
				so you may commit them at once using the following note: <code>[DOCUMENTATION][GAMEPLAY] Added sections about
				teamplay and weapons.</code> You may also make two commits (as described in example 1). If you are undecided
				rather commit more often than less. (/jme)
			</para>
		</section>
		<section>
		    <title>(jme) Pushing</title>
		    <para>
				Don't forget to push your commits when you think you have completed a big step or your
				team needs your changes. Do not push after every commit. This will take too much ressources as
				there are taken several steps on every push on serverside. These include building JavaDoc and
				documentation ("DocBook") as well as e-mail notification to other developers.
				Note that your progressbar in push-dialog may seem freezed at 100% while server is building JavaDoc and
				Documentation. This is a totally normal behaviour. Please be patient!
			</para> 
		</section>

	</section>
	
	
	<section>
	
		<title>(fma) Continuous Integration</title>
		
		<para>
			We should really think about introducing a continuous integration platform such
			as <ulink url="http://jenkins-ci.org/">Jenkins</ulink>. These tools offer a lot
			of automating-mechanisms which we can use to automate various jobs such as building
			the project or documentation, running unit tests and so on. It also is able to
			provide an overview of TODOs in	the source code and much more. We c.ould also integrate
			these features into our own web-platform being developed by Jannis
			But I think that would be much too costly. Using Jenkins (or another CI tool)
			as an extension to our platform should work well.
		</para>
	</section>
	
	<section>
		<title>(fma) Documentation</title>
		
		<para>
			We use <ulink url="http://docbook.org/">DocBook</ulink> to write our documentation.
			DocBook is written in an XML format and thus is very easy to convert to various
			types of documents. Primarily we will concentrate on optimizing our documentation for
			a good HTML output.
		</para>
		
		<section>
			
			<title>How to write documentation</title>
			
			<para>
				There are only small limitations on how to write documentation in this project.
				Feel free to add anything that in your opinion should be
				mentioned in the documentation. After consultation with other developers involved in
				the project, change parts of the documentation to fit to new ideas, but
				please <emphasis>DO NOT SIMPLY ERASE DOCUMENTATION THAT IS OUT OF DATE!
				</emphasis> Instead you should mark obsolete documentation by <emphasis role="strike">scratching
				out</emphasis> the text. Therefore, use <code>&lt;emphasis role="strike"&gt;text&lt;/emphasis&gt;</code>.
			</para>
			
			<para>
				If you write a new section of documentation, please insert your acronym as a prefix
				to the section's title, so people are able to easily ask questions if there are any.
				You should also do so if you add some sentences or do some changes. To mark the end
				of your changes or additional sentences, insert your prefix with a slash ('/').
			</para>
			
			<para>Example: My penis is very large. (jme) Mine is even larger. (/jme).</para>
			
		</section>
		
		<section>
		
			<title>Diagrams</title>
			
			<para>
				Diagrams are made with <ulink url="www.visual-paradigm.com">Visual Paradigm (VP)</ulink>.
				This is an intuitive "get what you see"-tool for creating UML-diagrams. There are plugins
				for Eclipse and NetBeans, so it will be comfortable for you to use VP. I think, we should
				not have any rules or restrictions for how to make diagrams. Simply take care for keeping things simple
				but meaningful.
			</para>
		
		</section>
	
	</section>
	
	<section>
	
		<title>(fma) Project management platform</title>
		
		<para>
			If the project is going to grow in number of members, I think there is a need for a project
			management platform which serves task management and gives a central entry point to continuous
			integration and version control. We will need that because we have to work distributed in terms
			of place and time. We could either develop an own platform serving these purposes or use an
			existing tool. <ulink url="http://www.tinypm.com/">tinyPM</ulink> provides task management and
			a git plugin giving an entry point to our git repository. Unfortunately, tinyPM is limited to
			at most 5 members on one project. We should discuss what aspects of project management we need
			and what the costs for integrating it into an own platform would be, what alternatives to
			tinyPM exist and, at last, what would be most adequate for us. Especially Jannis should tell
			his opinion.
		</para>
	
	</section>
	
	<section>
		
		<title>(fma) Process model</title>
		
		<para>
			This is a hobby project that nevertheless is intended to grow to a relativly big one. So
			I guess progress will be slow and over a long period of time since we can't work fulltime
			on it - knowledge may get lost over time. Earlier or later there will be much code written 
			by a lot of	different people assumed that developer fluctuation will be high. Due to these
			reasons we need a detailed documentation to keep know-how about the project. Nevertheless
			an incremental and agile approach fits best to developing a game whose requirements often
			change. I propose to proceed in small increments in sprints over a (for a hobby project) 
			short period of time of about one month (or something). An incrementation should be devided
			into relativly big meta tasks, so there is one or at most 2 per developer (per sprint). 
			The developer may decide autonomously if he or she wants to devide his/her task into subtasks.
			A meta task should include writing adequate documentation including somehow architecture.
		</para>
		<para>
			For example, a first sprint may concern itself with setting up a basis for a client-server
			structure. In the very beginning the team has to discuss about interfaces, general
			architecture and about how the transmitted data should look like. Having specified these
			things, one part of the team can concentrate on implementing the client side and the other
			part can concentrate on the server side. Maybe a third part of the team can concern itself
			with data structures.
		</para>
		
		<para>
			TODO: Describe the process model in more detail!
		</para>
		
	</section>
	
</article>
