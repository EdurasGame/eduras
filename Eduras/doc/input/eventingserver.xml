<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
	<articleinfo>
		<title>Eventing Server</title>
		<author>
			<firstname>Florian</firstname>
			<surname>Mai</surname>
		</author>
	</articleinfo>

	<section>
	    <title>What's this about?</title>
	    <para>
	        As the development of Eduras was proceeding we experienced more and more problems
	        implementing new features that heavily rely on network mechanisms. It turned out
	        that our network layer was not well defined and network and game logic modules were
	        rather geared than encapsuled. This page describes what the Eventing Server, developed
	        to address those issues, is intended to do, how it does that and how you can use it
	        both in general and specifically for Eduras.
	    </para>
	</section>
	<section>
	    <title>Capabilities and Limits</title>
	    <para>
	        The Eventing Server is a stack that allows you to build up a client-server architecture
	        without actually having to access the transport layer directly. Nevertheless it provides
	        all the flexibility you need. You can transmit any information you may need. With that
	        information you can do whatever you want. You can use both the UDP and TCP protocols.
	        You will be informed of all events that happen on the network and are interesting to you.
	        However, you will need a plan on how to represent the information, what to do with it,
	        whether it's more useful to transmit it via TCP or UDP and how to react on network events.
	    </para>
	</section>
	<section>
	    <title>How to use</title>
	    <para>Server and clients communicate via so called 'Events'. Events have a unique identifier and
	    come with information provided by you. To create an Event use the Event(int eventNumber).
	    If you want two Events to be processed differently you must assign them different numbers.
	    To put information into the event use the putArgument(Object argument) method. Floats, Doubles,
	    Strings, Integers, Longs and Booleans will be serialized automatically. For any other kind of
	    object you will have to provide your own serialization. Once an Event arrives at either the
	    client or the server the respective EventHandler is called to process your event. Your job
	    is to define an EventHandler for the client and server (not necessarily the same) where you
	    determine depending on the Event (make a switch over the event number) what to do. You can
	    access the information contained in the event with the getArgument(int i) method. The
	    arguments are placed in the same order as they had been put on the other side before.
	    Whether Events are transmitted via TCP or UDP is determined by the NetworkPolicy. Inherit
	    from this class and implement the determinePacketType(Event event) method. Make a switch
	    over the event number and return depending on it either PacketType.UDP or PacketType.TCP.
	    If you don't specify a NetworkPolicy the default behavior is that all Events are transmitted
	    via TCP.
	    </para>
	    <section>
	        <title>Client</title>
	    <para>
	        For the implementation of the client side the following classes are interesting to you
	        (besides the already mentioned classes above):
	        <itemizedlist>
	            <listitem>
	                ClientInterface: This will be your primary tool to manage a clients behavior. You
	                use it to connect to and disconnect from a server and to configure the
	                behavior when you receive Events or when some network action is taking place.
	            </listitem>
	            <listitem>
	                ClientNetworkEventHandler: Implement this interface and set it on the Client
	                in order to be informed of all network actions that take place and are interesting
	                to the client.
	            </listitem>
	        </itemizedlist>
	    </para>
	    </section>
	    <section>
	        <title>Server</title>
	        <para>
	            For the implementation of the server side the following classes are interesting to you
	        (besides the already mentioned classes above):
	        <itemizedlist>
	            <listitem>
	                ServerInterface: This will be your primary tool to manage the server's behavior.
	                You use it to start or stop listing to clients on a specific port, to kick clients
	                and to manage the server's behavior when receiving Events or something happens on
	                the network that is interesting to the server.
	            </listitem>
	            <listitem>
	                ServerNetworkEventHandler: Implement this interface and set it on the Server
	                in order to be informed of all network actions that take place and are interesting
	                to the server.
	            </listitem>
	        </itemizedlist>
	        </para>
	    </section>
	</section>
	<section>
	    <title>What's inside</title>
	    <para>
	        The inside of the Eventing Server looks like the following:
	    </para>
	    <figure>
            <title></title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="images/network.jpg" format="JPG" />
                </imageobject>
            </mediaobject>
        </figure>
	    <para>
	        TODO: Update the above figure and describe what it says.
	    </para>
	</section>
	<section>
	    <title>Eventing Server in Eduras</title>
	    <para>
	        <emphasis role="strike">There are no big changes to be done in order to get Eduras running
	    	with the Eventing Server as underlaying layer. The former NetworkMessageSerializer and
	    	-Deserializer must be rewritten such that they write to and read the Event's arguments
	    	using the putArgument() and getArgument() method. This is then set as the EventHandler of
	    	the EventingServer. Once a GameEvent is created, it can be passed to logic just as before.
	    	GameEvents' method names can stay the
	    	same so the logic will not have to be changed a lot. However, the methods body must be
	    	rewritten such that they use getArgument(i) with the correct i. The handling of NetworkEvents
	    	is replaced by direct callbacks. The callbacks bodys can mostly be adopted from the handling
	    	of the former NetworkEvents. </emphasis>
	    	The former Event system was transformed as follows: All GameEvents inherit from eventingserver.Event
	    	and the old Event class was deleted. The NetworkEvent class was deleted too as it has become
	    	obsolete due to the internal events that were introduced in the EventingServer. The handler's that
	    	had handled those NetworkEvents were replaced by handlers that do the same but are called when
	    	the events appear internally. The InitInformation and GameReady events are specific to Eduras, so
	    	they were made GameEvents.
	    	All Events (or types of events) have a unique number which identifies them.
	    	(it's basically the same as the GameEventNumber but a real integer so you can generalize it)
	    	Every event gets its semantics through the arguments it's containing. Consider two differenct Eventtypes of which you
	    	know that the Event with #1 has two arguments that are strings and Event with #2 has 3 arguments that
	    	are a string, a double and an integer. The set up for the events would look like this:
	    	
	    	To set up and handle your events properly, there is basically two approaches:
	    	
	    	1. You can simple put your arguments in the same order as they are deserialized with the putArgument()
	    	method. Consider the following code:
	    	<programlisting>
	    	String stringArg1 = "something"; // the string you wanna pass via the event
	    	String stringArg2 = "somethingElse"; // another string you wanna pass
	    	Event aStringEvent = new Event(1); // create an event that is identified by the number 1
	    	aStringEvent.putArgument(stringArg1); // put your strings as arguments into the event
	    	aStringEvent.putArgument(stringArg2);
	    	client.sendEvent(aStringEvent); // send the event ; must not necessarily be a client, can be the server as well
	    	
	    	Event anotherEvent = new Event(2);
	    	String myString = "lol";
	    	double myDouble = 101.101;
	    	int myInteger = 101;
	    	anotherEvent.putArgumet(myString);
	    	anotherEvent.putArgumet(myDouble);
			anotherEvent.putArgumet(myInteger);
			server.sendEvent(anotherEvent);
			</programlisting>
	    	2. Another way is to inherit from the Event class and overwrite the getArgument(i) and getNumberOfArguments() methods.
	    	Consider the following code:
	    	
	    	<programlisting>
	    	
	    	class SexEvent extends Event {
	    		private int penisLength;
	    		private double numberOfSpermsPerCentimeter;
	    		
	    		private String pussyName;
	    		private Boolean isWet;
	    		
	    		private static final int FRAU = 42;
	    		private static final int MANN = 23;
	    		
	    		// some constructors
	    		...
	    		// some methods
	    		...
	    		
	    		public Object getArgument(int i) {
	    			switch(getEventNumber()) {
	    			case MANN:
	    					switch(i) {
	    					case 0: return penisLength;
	    					case 1: return numberOfSpermsPerCentimeter;
	    					}
	    			case FRAU:
	    					switch(i) {
	    					case 0: return pussyName;
	    					case 1: return isWet;
	    					}
	    			}
	    		}
	    		
	    		public int getNumberOfArguments() {
	    			switch(getEventNumber()) {
	    			case MANN: return 2;
	    			//case FRAU: return 3; // this could lead to errors, as there are only 2 arguments!
	    			case FRAU: return 2;
	    			}
	    		}
	    	}
	    	</programlisting>
	    	During serializing, the internal methods will use an Events' getArgument and getNumberOfArguments methods.
	    	If you do not overwrite them, they simply consist of reading a list that had been filled with putArgument()
	    	before and giving back the list's length respectivly.
	    	As you can see you can give your code more structure through inheriting from Event and giving
	    	your inheriting classes meaningful names. Furthermore, you can wrap several distinct events in
	 		one class when you overwrite the methods as seen above. The Eduras code uses that mechanism in the
	 		MovementEvents, ItemEvents and ObjectFactoryEvents for example.
	 		
	 		All your events will be deserialized to basic events. You can access the arguments with the getArgument() method
	 		then in the same order as you put it.
	    	
	    	<programlisting>
	    	
	    	...
	    	switch(event.getEventNumber()) {
	    	case 1: 
	    		String stringArg1 = (String) event.getArgument(0);
	    		String stringArg2 = (String) event.getArgument(1);
	    		doSomething(stringArg1, stringArg2);
	    		break;
	    	case 2:
	    		String myString = (String) event.getArgument(0);
	    		double myDouble = (Double) event.getArgument(1);
	    		int myInteger = (Integer) event.getArgument(2);
	    		doSomethingElse(myString,myDouble,myInteger);
	    	}
	    	...
	    	</programlisting>
	    	To preserve your event hierarchy structure, you could then do something like this:
	    	
	    	<programlisting>
	    	private void doSomething(String str1, String str2) {
	    		MyStringEvent myStringEvent = new MyStringEvent(str1, str2);
	    		
	    		... // further processing
	    	}
	    	
	    	private void doSomethingElse(String str, double d, int i) {
	    		new OtherEvent(str,d,i).processMe();
	    	}
	    	
	    	...
	    	
	    	</programlisting>
	    </para>
	</section>
</article>